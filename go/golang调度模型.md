# golang 调度模型

> 用户线程与内核线程是N:M多对多的关系

> [参考文章](https://segmentfault.com/a/1190000016824319)

> [参考文章](https://juejin.im/entry/5b2878c7f265da5977596ae2)

## GMP 模型

### seched 

调度器， 内部存储了空闲的M队列，空闲的P队列，可运行的G队列，自由的G队列以及一些调度状态信息

### M

抽象了 os 的内核线程，代表着真正被执行的计算器资源（线程），M目前最多数量为10000，M不保存G的状态信息，G可以在不同的M中执行

### P

`分配执行的上下文`，同时能执行的G的数量，<= 内核数量，角色相当于CPU的核

### G

每一次执行 go func 都会生成一个G，并加入到本地G队列中，等待M生成G的上下文，也就是绑定P来执行函数


## 调度

Seched 生成一个M以后，M需要绑定一个P，接着M会生成一个 os 线程，循环执行P上的可执行G队列。 如果P上的本地队列没有了，则会从全局队列中取G，如果还没有，则从其他的P队列中取一半的G任务放到自己本地队列中

### 遇到阻塞时

1. 用户态的阻塞/唤醒

当 goroutine 遇到 channel 或者 io 阻塞时，对应的G会被放到 wait 队列，并从_Gruning状态转到_Gwaitting， M获取并执行下一个G，如果没有G给M运行了，那么M和P解绑，M进入sleep 状态， 当G被另外的G2唤醒时，（比如channel的可读/写通知），G被标记为runnable，尝试加入G2所在的P的 runnext，然后再是P的Local队列和Global队列。

2. 系统调用阻塞

当G被阻塞在某个系统调用时，G被标记为_Gsyscall，M也处于block on syscall状态，此时M与P解绑，P尝试与其他 idle 的M绑定，如果没有，则建立一个M，当系统调用完成后，G会重新尝试获取一个 idle 的P，放到 local 队列恢复执行，如果没有，则进入global 队列


