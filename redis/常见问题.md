## redis的过期策略以及内存淘汰策略？

### 过期策略

过滤策略使用定期删除+惰性删除

redis  每隔一段时间从设置了过期时间的字典中随机抽取一定数量的 key，检查过期时间，如果过期了，删除，如果这次回收数量达到一定比例，那么再次随机抽取一定数量的 key，反复如此

获取某个 key 时，redis 会检查他的 ttl，如果过期了，进行删除


### 淘汰策略

如果内存占用实在太高了，过期策略来不及生效，则使用淘汰策略

1. noeviction

内存不足了，不写入新的 key，一般不会用

2. allkeys-lru 

移除最少使用的 key

3. allkeys-random

随机删，还不如第二种

4. volatile-lru

在设置了了过期时间的 key 中，移除最少用的，一般在持久化存储的 redis 中会使用

5. volatile-random

在设置了了过期时间的 key 中 随机删除

6. volatile-ttl

在设置了了过期时间的 key 中，删除最快过期的

## 数据库 redis 双写一致问题

如果对数据要极高的一致性，最好不要放缓存

非要放缓存的话，先更新数据库，再删缓存，最好再提供的队列，过一阵子再删一次，防止删失败

## 应对缓存穿透问题

> 请求缓存中不存在的数据，导致所有请求都打到数据库上

1. 利用互斥锁，拿到锁才去请求数据库，否则 sleep 一会重新读缓存

2. 提供拦截器，比如布隆过滤器判断缓存 key 是否有效

## 应对缓存雪崩

> 缓存在同一时间大面积失效，这时又有很多请求进来

1. 缓存时间加随机值

2. 双缓存，A有时间，B无时间，读到B的时候，异步去跑一个任务把缓存A更新了

## redis 的事务机制

begin commit rollback ，使用 管道运行所有命令

十分鸡肋，在redis-cluster 中没办法用。

## 争抢 key

多个线程同时要 set 一个 key 时，可以使用分布式锁，抢到锁以后去 set

## 基于 redis 的分布式锁

使用 set key xxx  nx es 进行加锁，成功的话即获得锁

解锁时，还要判断这个锁是否是自己的，防止时间过长，锁被别人解了


