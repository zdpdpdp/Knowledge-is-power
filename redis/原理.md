# 原理


## 线程 io 模型

> redis 属于单线程架构，不存在并发问题,但是处理速度非常快

1. 内存级别运算

2. 多路复用，非阻塞 io



### io 数据流
 
 > 对于 socket 流而言,io 数据流经历两个阶段

 1. 等待网络上的数据分组到达，被复制到内核缓冲区中
 2. 把数据从内核缓冲区复制到应用进程缓冲区

### io 模型
- blocking io

阻塞 io，linux 默认 io,read 时指定读取多少字节，等到读满或者连接断开程序才能走下一步


- nonblocking io

linux 中通过设置 non-block 参数使socket成为非阻塞io,读写时立即从内核进行 io，并返回成功字节数或者错误，需要用户进程自己去循环读取


- io multiplexing

> 通过 select poll epoll进行 io 多路复用

select/poll 监听遍历多个文件描述符，当某文件描述符就绪时，可以立刻返回， 在文件描述符过多时，效率会变差

epoll 是改良版的 select/poll， 只遍历那些ready 的描述符

- asynchronous IO

异步 io，通过异步回调的方式处理 io

### 定时任务

> redis 既然是单线程架构，那么是如何处理定时任务的？

redis 将定时任务记录在最小堆中，在每次循环周期内立即将最小堆任务处理，并且使用下次任务所需要的时间作为 select 的 time out

## 通信协议

> redis 使用文本协议作为通信协议，包含了大量的\r\n， 但是性能仍然很高

## 持久化

> redis 数据在内存中，但是提供了持久化方法，redis 重启时，可以恢复数据

### RDB快照

进行一次全量备份,使用COW fork 了一个子进程进行备份，在 fork 时，子进程仍然和父进程共享内存，当父进程修改内存后，os 会复制对应的内存页出来，然后对这个内存页进行修改


### AOF日志

AOF存储了Redis对内存修改的指令记录，在长期运行中，AOF越来越大，导致重启时间长，因此REDIS提供了重写的方式对AOF日志瘦身。其原理是开辟一个字进程对内存进行遍历，转换为一系列 redis 操作指令，序列完后，将增量的AOF追加到新的AOF中，并替换旧的日志

### fsync

AOF以日志文件形式存在，redis 先把指令写到了内存缓存中，再异步将数据刷到磁盘中，但是如果机器突然挂掉，AOF还没完全写到磁盘中，会发生日志丢失.

redis 提供了 fsync将指定文件强制从内存刷到磁盘中，他是磁盘操作，非常慢，通常我们配置1s调用一次。 因此 redis 可能会丢失1s 内的指令.

### 运维

redis 使用从节点进行持久化

## 管道

客户端将多个命令一起发送到服务端，节省来回 ttl 时间


## 事务

> multi/exec/discard 进行事务, redis事务仅提供隔离功能，不会要么全部失败，要么全部成功。 multi 开启后，所有指令进入一个队列中

redis中事务管道一起使用

非原子性事务操作可以使用加锁（悲观锁）, watch(乐观锁)进行

## PubSub 多播订阅

1. 支持多订阅，模式订阅
2. 不支持持久化，如果没有消费者，信息直接丢掉。因此消费者重启时，收不到之前的消息

## 主从同步


一句话概括 CAP 原理就是——网络分区发生时，一致性和可用性两难全
Redis主从同步：

1。 增量追赶，写指令流同步
2。 增量太慢了，全量追赶，快照同步
3。 无盘复制，生产快照是一个遍历的过程
主从主要是为了保障Redis的高可用性，同时也能兼顾提升性能

## 过期策略

> redis 会将每个设置了过期时间的 key 放到一个独立的字典中，使用定时删除和惰性删除两种策略结合

1. 从过期字典中随机 20 个 key；
2. 删除这 20 个 key 中已经过期的 key；
3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；

同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。

## 淘汰策略

> redis 使用内存超出了物理内存限制时，内存和硬盘之间会产生大量的交换，导致 redis 性能下降，因此生产环境我们会使用maxmemory 限制内存大小。当实际内存超出 maxmemory 时，会执行 redis 的淘汰策略


### 惰性删除

读取时发现过期了，才删除

### 懒惰删除

只使用 unlink， 不释放内存，后台线程来异步回收内存


- noeviction
不处理写请求

- volatile-lru
淘汰设置了过期时间的 key，最少被使用的先淘汰

- volatile-ttl 
淘汰设置了过期时间的 key，ttl 最小的会被淘汰

- volatile-random 
淘汰设置了过期时间的 key，随机选取

- allkeys-lru
全体 key 最少被使用

- allkeys-random
全体 key 随机

### LRU算法

> 实现一个链表，被使用的 key 移到头部

### 近似LRU

> redis使用的，节省内存


## 指令安全

> rename-command 重命名命令